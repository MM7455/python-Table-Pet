import sys
import os
import re
import requests
import random
import psutil
import win32gui
import pygetwindow as gw
from PyQt6.QtWidgets import QApplication, QWidget, QLabel, QMenu, QPushButton,QVBoxLayout,QLineEdit,QInputDialog, QMessageBox, QTextEdit
from PyQt6.QtGui import QPixmap, QPainter, QGuiApplication, QCursor
from PyQt6.QtCore import Qt, QPoint, QTimer, QThread, pyqtSignal

script_dir = os.path.dirname(os.path.abspath(__file__))
os.chdir(script_dir)

QGuiApplication.setHighDpiScaleFactorRoundingPolicy(
    Qt.HighDpiScaleFactorRoundingPolicy.PassThrough
)

os.environ["DEEPSEEK_API_KEY"] = "api"
api_key = os.getenv("DEEPSEEK_API_KEY")

def load_images(folder):
    """ ä»æ–‡ä»¶å¤¹è¯»å–æ‰€æœ‰ PNG å›¾ç‰‡ï¼ŒæŒ‰æ–‡ä»¶åä¸­çš„æ•°å­—é¡ºåºæ’åº """
    files = sorted(
        [f for f in os.listdir(folder) if f.endswith(".png")], 
        key=lambda x: int(re.search(r'\d+', x).group())  # æå–æ–‡ä»¶åä¸­çš„æ•°å­—éƒ¨åˆ†æ’åº
    )
    return [QPixmap(os.path.join(folder, f)) for f in files]

from requests.exceptions import RequestException, HTTPError  # æ–°å¢è¿™è¡Œ

class DeepSeekAI:
    BASE_URL = "https://api.deepseek.com/v1" #å­˜å‚¨APIåŸºç¡€åœ°å€
    
    @staticmethod #éªŒè¯ç¯å¢ƒå˜é‡æ˜¯å¦è®¾ç½®
    def validate_key():
        if "DEEPSEEK_API_KEY" not in os.environ:
            raise RuntimeError("æœªæ£€æµ‹åˆ°DEEPSEEK_API_KEYç¯å¢ƒå˜é‡")

class AIWorker(QThread): #å‘é€APIè¯·æ±‚
    """ åå°AIå¤„ç†çº¿ç¨‹ """
    response_received = pyqtSignal(str)
    error_occurred = pyqtSignal(str)

    def __init__(self, prompt, mode="chat"):
        super().__init__()
        self.prompt = prompt
        self.mode = mode
        self.api_key = os.getenv("DEEPSEEK_API_KEY")
        self.last_window = ""
        self.timer = QTimer()
        self.worker = None
 
    def generate_response(self, window_title):
        """æ ¹æ®çª—å£æ ‡é¢˜ç”Ÿæˆ AI åæ§½"""
        url = "https://api.deepseek.com/v1/chat/completions"

        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }

        prompt = f"""
                    ç”¨1-12ä¸ªå­—ååº”å½“å‰ç”¨æˆ·æ­£åœ¨ä½¿ç”¨çš„çª—å£ã€{window_title}ã€‘ï¼Œä¸è¦è§£é‡Šç›´æ¥è¾“å‡º
                    ä¾‹å¦‚ï¼šå½“VS code æ—¶ï¼šç´¯æ­»ä½ ç®—äº†ğŸ˜‰
                    ä¾‹å¦‚ï¼šå½“pornhub æ—¶ï¼šè®°å¾—é”é—¨å“¦ğŸ”’
                    ä¾‹å¦‚ï¼šå½“steam æ—¶ï¼šä½œä¸šå†™äº†å—ğŸ‰
                """
        data = {
            "model": "deepseek-chat",
            "messages": [{"role": "system", "content": prompt}],
            "temperature": 1
        }

        try:
            response = requests.post(url, headers=headers, json=data, timeout=10)
            response.raise_for_status()
            reply = response.json()["choices"][0]["message"]["content"]
            print(f"AI å›å¤: {reply}")
            self.response_received.emit(reply)  
        except Exception as e:
            print(f"AIè¯·æ±‚å¤±è´¥: {e}")
            self.setText("ç›¯ç€ä½ å‘¢ğŸ‘€")  # å¤±è´¥æ—¶é»˜è®¤æ–‡æœ¬

    def handle_chat(self):
        """ å¤„ç†èŠå¤©æ¨¡å¼ """
        try:
            response = requests.post(
                "https://api.deepseek.com/v1/chat/completions",
                headers={
                    "Authorization": f"Bearer {self.api_key}",
                    "Content-Type": "application/json"
                },
                json={
                    "model": "deepseek-chat",
                    "messages": [
                        {"role": "system", "content": "å›ç­”ä¸éœ€è¦è§£é‡Šï¼Œç›´æ¥ç”¨ç®€æ´çš„çŸ­è¯­éª‚ç”¨æˆ·"},
                        {"role": "user", "content": self.prompt}
                    ],
                    "temperature": 1,
                },
                timeout=15
            )
            
            response.raise_for_status()
            data = response.json()
            
            if "choices" not in data:
                raise ValueError("æ— æ•ˆAPIå“åº”ç»“æ„")
            
            reply = data["choices"][0]["message"]["content"]
            print(f"ğŸ¤– AI éª‚äººæ¨¡å¼å›å¤: {reply}")  
            self.response_received.emit(reply.strip())  

        except Exception as e:
            print(f"âŒ AIè¯·æ±‚å¤±è´¥: {e}")
            self.response_received.emit("éª‚ä¸åŠ¨äº†ğŸ˜µâ€ğŸ’«")

    def run(self):
        print(f"ğŸ›  çº¿ç¨‹å¯åŠ¨, mode={self.mode}")
        if self.mode == "chat":
            self.handle_chat()
        elif self.mode == "window":
            self.generate_response(self.prompt)

        self.exec()

class ChatWindow(QWidget):
    """ èŠå¤©çª—å£ï¼Œæ˜¾ç¤º AI å›å¤å¹¶è¾“å…¥æ¶ˆæ¯ """
    def __init__(self, pet):
        super().__init__()
        self.pet = pet  # ç»‘å®šæ¡Œå® 
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)

        self.setFixedSize(250, 100)  # å›ºå®šçª—å£å¤§å°
        self.move(self.pet.x() + 100, self.pet.y() - 50)  # é»˜è®¤åœ¨æ¡Œå® å³ä¸Šè§’

        self.chat_label = QLabel("", self)
        self.chat_label.setStyleSheet("background-color: white; border-radius: 5px; padding: 5px;")
        self.chat_label.setWordWrap(True)
        self.chat_label.setGeometry(10, 10, 230, 40)  # èŠå¤©æ°”æ³¡åŒºåŸŸ

        self.roast_label = QLabel("", self)
        self.roast_label.setStyleSheet("background-color: white; border-radius: 5px; padding: 5px;")
        self.roast_label.setWordWrap(True)
        self.roast_label.setGeometry(10, 10, 230, 40)  # èŠå¤©æ°”æ³¡åŒºåŸŸ

        self.input_box = QLineEdit(self)
        self.input_box.setPlaceholderText("å’Œæˆ‘èŠå¤©å§ï¼")
        self.input_box.setGeometry(10, 60, 230, 30)
        self.input_box.returnPressed.connect(self.process_input)

        self.chat_timer = QTimer(self)
        self.chat_timer.setSingleShot(True)
        self.chat_timer.timeout.connect(self.chat_label.hide)  # 5ç§’åéšè— chat_label

        self.roast_timer = QTimer(self)
        self.roast_timer.setSingleShot(True)
        self.roast_timer.timeout.connect(self.roast_label.hide)  # 3ç§’åéšè— roast_label

        print("âœ… å®šæ—¶å™¨åˆå§‹åŒ–å®Œæˆ")

        self.worker = None
        self.last_window = None
        self.mode = "window"
        self.timer = QTimer()  # è®© QTimer åœ¨ä¸»çº¿ç¨‹è¿è¡Œ
        self.timer.timeout.connect(self.check_window)  
        self.timer.start(5000)
        self.hide()  # åˆå§‹éšè—

        self.start_window_monitor()

    @staticmethod #è§£å†³selfç±»é—®é¢˜
    def get_active_window_title():
        hwnd = win32gui.GetForegroundWindow()  # è·å–å½“å‰çª—å£çš„å¥æŸ„
        if hwnd:
            window_title = win32gui.GetWindowText(hwnd)  # è·å–çª—å£æ ‡é¢˜
            return window_title
        return None

    def start_window_monitor(self):
        """ ä»¥å®šæ—¶æ–¹å¼æŒç»­æ£€æµ‹çª—å£æ ‡é¢˜ """
        if self.worker and self.worker.isRunning():
            print("âœ… çª—å£ç›‘è§†å·²åœ¨è¿è¡Œ...")
            return
        self.worker = AIWorker("", mode="window")
        self.get_ai_response("", mode="window")
        self.timer = QTimer()
        self.timer.timeout.connect(self.check_window)  # æ¯æ¬¡å®šæ—¶å™¨è§¦å‘ï¼Œæ£€æŸ¥çª—å£
        self.timer.start(2000)  # æ¯2ç§’æ£€æŸ¥ä¸€æ¬¡çª—å£

    def check_window(self):
        window = gw.getActiveWindow()
        if window is None:
            print("âŒ æ²¡æœ‰æ£€æµ‹åˆ°æ´»è·ƒçª—å£")
            return  # ç›´æ¥è¿”å›ï¼Œä¸ç»§ç»­æ‰§è¡Œ   
        window_title = window.title
        print(f"ğŸ” æ£€æµ‹å½“å‰çª—å£: {window_title}")
        print(f" å½“å‰æ¨¡å¼: {self.mode}")
        if not window_title:
            print("âš ï¸ çª—å£æ ‡é¢˜ä¸ºç©ºï¼")
            return
    
        if window_title != self.last_window:  # åªæœ‰çª—å£å˜åŒ–æ—¶æ‰è§¦å‘
            self.last_window = window_title
            print(f"{window_title}")  # æ‰“å°çª—å£åç§°
            self.get_ai_response(window_title, mode="window")  

    def process_input(self): #ENTERåæ‰§è¡Œ
        """ å¤„ç†ç”¨æˆ·è¾“å…¥å¹¶è·å– AI å›å¤ """
        text = self.input_box.text().strip()
        if not text:  # å¦‚æœç”¨æˆ·è¾“å…¥ä¸ºç©º
           self.chat_label.setText("ä½ è¯´ä»€ä¹ˆ~")  # ç»™ä¸ªæç¤º
           return
         # è¿›å…¥èŠå¤©æ¨¡å¼ï¼Œç¦ç”¨åæ§½
        
        self.input_box.hide()  # éšè—è¾“å…¥æ¡†
        self.get_ai_response(text, mode="chat")
        # åˆ¤æ–­å½“å‰æ¨¡å¼ï¼Œç»‘å®šä¸åŒçš„ä¿¡å·
        if self.mode == "chat":
            self.worker.response_received.connect(self.display_chat_response)
        elif self.mode == "window":
            self.worker.response_received.connect(self.display_roast_response)
        else:
            self.worker.response_received.connect(self.display_chat_response)  # é»˜è®¤ç”¨èŠå¤©æ¨¡å¼

        self.worker.error_occurred.connect(self.display_error)
        self.worker.finished.connect(self.reset_worker)
        self.worker.start()


    def get_ai_response(self, text, mode="chat"):
      
        print(f"ğŸš€ è¯·æ±‚ AI å“åº”: {text}, mode={mode}")
        self.worker = AIWorker(text, mode=mode)

        # æ ¹æ® mode é€‰æ‹©ä¸åŒçš„ä¿¡å·å¤„ç†æ–¹æ³•
        if mode == "chat":
            self.worker.response_received.connect(self.display_chat_response)
            self.chat_label.setText("æ€è€ƒä¸­...")  # å¤„ç†æ™®é€šèŠå¤©
        elif mode == "window":
            self.worker.response_received.connect(self.display_roast_response)  # å¤„ç†åæ§½

        self.worker.error_occurred.connect(self.display_error)  # å¤„ç†é”™è¯¯
        print("ğŸ”— è¿æ¥ AIWorker ä¿¡å·åˆ°ç›¸åº”çš„ display æ–¹æ³•")

        self.worker.finished.connect(self.reset_worker)  # çº¿ç¨‹ç»“æŸåæ¸…ç†
        self.worker.start()

    def display_chat_response(self, reply):
        """ å¤„ç†æ­£å¸¸èŠå¤© """
        print(f"ğŸ’¬ èŠå¤©å›å¤: {reply}")
        self.chat_label.setText(reply)
        self.chat_label.adjustSize()
        self.adjustPosition()
        self.chat_label.repaint()  # å¼ºåˆ¶ UI ç«‹å³é‡ç»˜
        self.chat_label.update() 
        self.input_box.hide()
        self.chat_label.raise_()
        self.chat_timer.start(5000) 
        QTimer.singleShot(5000, self.reset_mode_to_window)

    def display_roast_response(self, reply):
        """ å¤„ç†åæ§½ """
        if self.mode == "chat":
            print("ğŸš« èŠå¤©æ¨¡å¼ï¼Œå¿½ç•¥åæ§½")
            return
        print(f"ğŸ”¥ åæ§½å›å¤: {reply}")
        self.roast_label.setText(reply)
        self.roast_label.adjustSize()
        self.adjustPosition()
        self.roast_label.repaint()  # å¼ºåˆ¶ UI ç«‹å³é‡ç»˜
        self.roast_label.update() 
        self.roast_label.window().show()
        self.roast_label.setVisible(True)  # åˆ·æ–° UI
        self.roast_label.show()
        self.chat_label.hide()
        self.input_box.hide()
        self.roast_label.raise_()
        self.roast_timer.start(3000) 

    def display_error(self, error_msg):
        """ å‘ç”Ÿé”™è¯¯æ—¶æ˜¾ç¤º """
        self.chat_label.setText(error_msg)
        self.chat_label.adjustSize()
        self.adjustPosition()
        QTimer.singleShot(10000, self.chat_label.hide)

    
    def adjustPosition(self):
        """ ç¡®ä¿èŠå¤©æ¡†åœ¨æ¡Œå® æ—è¾¹ """
        self.move(self.pet.x() + 100, self.pet.y())

    def reset_worker(self):
        self.worker = None

    def reset_mode_to_window(self):
        """ 5 ç§’åæ£€æŸ¥æ˜¯å¦ä»ç„¶å¤„äºèŠå¤©æ¨¡å¼ï¼Œé¿å…è¢«å…¶ä»–é€»è¾‘æ‰“æ–­ """
        if not self.chat_label.isVisible():
            self.mode = "window"
            print("ğŸ”µ 5 ç§’åè‡ªåŠ¨åˆ‡æ¢æ¨¡å¼: window") 

    def prepare_new_chat(self): 
        self.chat_label.hide()
        self.roast_label.hide()
        self.chat_label.setText("")
        self.input_box.clear()       # æ¸…ç©ºè¾“å…¥æ¡†
        self.input_box.show()        # ç¡®ä¿è¾“å…¥æ¡†å¯è§
        self.input_box.setFocus()
    
class DesktopPet(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)        
        # åŠ è½½ PNG å›¾ç‰‡
        self.idle_frames = load_images("animations/idle")
        self.dance_frames = load_images("animations/dance")
        self.drag_frames = load_images("animations/drag")
        self.frames = self.idle_frames
        self.frame_idx = 0
        self.is_dragging = False

        self.timer = QTimer()
        self.timer.timeout.connect(self.update_animation)
        self.timer.start(32)

        self.chat_window = ChatWindow(self)

        # **å³é”®èœå•**
        self.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.customContextMenuRequested.connect(self.on_context_menu_request)

    def update_animation(self):
        self.frame_idx = (self.frame_idx + 1) % len(self.frames)
        self.resize(self.frames[self.frame_idx].size())
        self.repaint()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.drawPixmap(0, 0, self.frames[self.frame_idx])

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self.drag_position = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
            self.is_dragging = True
            self.switch_to_drag()
            event.accept()

    def mouseMoveEvent(self, event):
        if event.buttons() & Qt.MouseButton.LeftButton:
            self.move(event.globalPosition().toPoint() - self.drag_position)
            self.chat_window.adjustPosition()
            event.accept()

    def mouseReleaseEvent(self, event):
        if self.is_dragging:
            self.is_dragging = False
            self.restore_animation()
            event.accept()

    def switch_to_drag(self):
        if self.frames != self.drag_frames:
            self.frames = self.drag_frames
            self.frame_idx = 0
            self.timer.setInterval(32)

    def restore_animation(self):
        if self.frames == self.drag_frames:
            self.frames = self.idle_frames
            self.frame_idx = 0


    def on_context_menu_request(self, pos):
        """ ä¸Šä¸‹æ–‡èœå•è¯·æ±‚çš„æ­£å¼å¤„ç† """
        self.chat_window.mode = "chat"
        print("ğŸŸ¢ è¿›å…¥èŠå¤©æ¨¡å¼")
        menu = QMenu(self)
        chat_action = menu.addAction("èŠå¤©")
        dance_action = menu.addAction("è·³èˆ")
        idle_action = menu.addAction("å¾…æœº")
        quit_action = menu.addAction("é€€å‡º")

        dance_action.triggered.connect(self.start_dance)
        chat_action.triggered.connect(self.toggle_chat)
        idle_action.triggered.connect(self.start_idle)
        quit_action.triggered.connect(self.safe_close)  # ä¿®æ”¹å…³é—­æ–¹å¼

        # ä½¿ç”¨ç»å¯¹åæ ‡æ˜¾ç¤ºèœå•
        menu.exec(self.mapToGlobal(pos))

        if not self.chat_window.isVisible():  # åªæœ‰èŠå¤©çª—å£æ²¡æ‰“å¼€æ—¶ï¼Œæ‰æ”¹å› window
            self.chat_window.mode = "window"
            print("ğŸ”µ é€€å‡ºèŠå¤©æ¨¡å¼ï¼Œå›åˆ°çª—å£ç›‘è§†")

    def toggle_chat(self):
        """ åˆ‡æ¢èŠå¤©æ¡†æ˜¾ç¤º/éšè— """
        print("ğŸ“¢ è§¦å‘äº†èŠå¤©æŒ‰é’®")
        self.chat_window.mode = "chat"
        print(f"9999 è¿›å…¥èŠå¤©æ¨¡å¼, å½“å‰æ¨¡å¼: {self.chat_window.mode}")
        if self.chat_window.isVisible():
            self.chat_window.hide()
        else:
            self.chat_window.show()
            self.chat_window.adjustPosition()
            self.chat_window.prepare_new_chat()
        
    def start_dance(self):
        self.frames = self.dance_frames
        self.frame_idx = 0
        self.timer.setInterval(16)

    def start_idle(self):
        self.frames = self.idle_frames
        self.frame_idx = 0
        self.timer.setInterval(32)

    def safe_close(self):
        if self.timer.isActive():
            self.timer.stop()
        self.chat_window.close()
        self.close()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    pet = DesktopPet()
    pet.show()
    sys.exit(app.exec())
